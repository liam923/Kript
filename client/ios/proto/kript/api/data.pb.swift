// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: kript/api/data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A permission that a user can have on a datum.
enum Kript_Api_Permission: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0

  /// Permission to read the datum.
  case read // = 1

  /// Permission to read and write the datum.
  case write // = 2

  /// Permission to read and delete the datum.
  case delete // = 3

  /// Permission to read and share the datum with other users. The user has the power
  /// to share the same permissions that they have.
  case share // = 4

  /// Full permission on the datum.
  case admin // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .read
    case 2: self = .write
    case 3: self = .delete
    case 4: self = .share
    case 5: self = .admin
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .read: return 1
    case .write: return 2
    case .delete: return 3
    case .share: return 4
    case .admin: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Kript_Api_Permission: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Kript_Api_Permission] = [
    .unknown,
    .read,
    .write,
    .delete,
    .share,
    .admin,
  ]
}

#endif  // swift(>=4.2)

struct Kript_Api_Datum {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifier of this datum.
  var id: String = String()

  /// The owner of this datum.
  var owner: String = String()

  /// The title of this datum, given by the user.
  var title: String = String()

  /// The actual data of this datum, such as a password or code, encrypted.
  var data: Kript_Api_ESecret {
    get {return _data ?? Kript_Api_ESecret()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  /// The encryption algorithm used to encrypt the actual data.
  var dataEncryptionAlgorithm: Kript_Api_SEncryptionAlgorithm = .unknownSEncryptionAlgorithm

  /// The initialization vector used to encrypt the data.
  var dataIv: Data = SwiftProtobuf.Internal.emptyData

  /// A map of ids of users who have access to this datum to information on what
  /// permissions they have. This does not include the owner, who has all permissions.
  var accessors: Dictionary<String,Kript_Api_Datum.Access> = [:]

  /// The metadata associated with this datum.
  var metadata: Kript_Api_Datum.Metadata {
    get {return _metadata ?? Kript_Api_Datum.Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An object representing relevant data to a user who has access to this
  /// datum.
  struct Access {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the user whom this access object is associated with.
    var userID: String = String()

    /// The key used to encrypt the actual data, encrypted using this user's
    /// public key and decrypted with their private key.
    var dataKey: Kript_Api_EBytes {
      get {return _dataKey ?? Kript_Api_EBytes()}
      set {_dataKey = newValue}
    }
    /// Returns true if `dataKey` has been explicitly set.
    var hasDataKey: Bool {return self._dataKey != nil}
    /// Clears the value of `dataKey`. Subsequent reads from it will return its default value.
    mutating func clearDataKey() {self._dataKey = nil}

    /// The list of permissions this user has on this datum.
    var permissions: [Kript_Api_Permission] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _dataKey: Kript_Api_EBytes? = nil
  }

  /// The metadata associated with this datum.
  struct Metadata {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The user who created and owns this datum.
    var ownerID: String = String()

    /// The time at which this datum was created.
    var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_createdTime = newValue}
    }
    /// Returns true if `createdTime` has been explicitly set.
    var hasCreatedTime: Bool {return self._createdTime != nil}
    /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
    mutating func clearCreatedTime() {self._createdTime = nil}

    /// The time at which this datum was last modified.
    var lastEdited: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _lastEdited ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_lastEdited = newValue}
    }
    /// Returns true if `lastEdited` has been explicitly set.
    var hasLastEdited: Bool {return self._lastEdited != nil}
    /// Clears the value of `lastEdited`. Subsequent reads from it will return its default value.
    mutating func clearLastEdited() {self._lastEdited = nil}

    /// A map of id of users with access or who once had access to metadata
    /// associated with that access.
    var accessMetadata: Dictionary<String,Kript_Api_Datum.Metadata.AccessMetadata> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Metadata associated with a user who had access to this datum at some
    /// point.
    struct AccessMetadata {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The grants and revokes that have been given to the user.
      var grantMetadata: [Kript_Api_Datum.Metadata.AccessMetadata.PermissionGrantMetadata] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Metadata associated with a change in access permissions.
      struct PermissionGrantMetadata {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// The id of the user who granted or revoked a permission.
        var granterID: String = String()

        /// The permission that was granted or revoked.
        var permission: Kript_Api_Permission = .unknown

        /// If true, this grant was a grant. Otherwise, it was a revoke.
        var isGrant: Bool = false

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    init() {}

    fileprivate var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _lastEdited: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  init() {}

  fileprivate var _data: Kript_Api_ESecret? = nil
  fileprivate var _metadata: Kript_Api_Datum.Metadata? = nil
}

struct Kript_Api_GetDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The access token to identify and authenticate the user.
  var accessToken: Kript_Api_AccessToken {
    get {return _accessToken ?? Kript_Api_AccessToken()}
    set {_accessToken = newValue}
  }
  /// Returns true if `accessToken` has been explicitly set.
  var hasAccessToken: Bool {return self._accessToken != nil}
  /// Clears the value of `accessToken`. Subsequent reads from it will return its default value.
  mutating func clearAccessToken() {self._accessToken = nil}

  /// The list of ids of datums to retrieve. If empty, all datums that the user
  /// has access to will be retrieved.
  var datumIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessToken: Kript_Api_AccessToken? = nil
}

struct Kript_Api_GetDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The datums requested by the user.
  var datums: [Kript_Api_Datum] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Kript_Api_UpdateDatumRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The access token to identify and authenticate the user.
  var accessToken: Kript_Api_AccessToken {
    get {return _accessToken ?? Kript_Api_AccessToken()}
    set {_accessToken = newValue}
  }
  /// Returns true if `accessToken` has been explicitly set.
  var hasAccessToken: Bool {return self._accessToken != nil}
  /// Clears the value of `accessToken`. Subsequent reads from it will return its default value.
  mutating func clearAccessToken() {self._accessToken = nil}

  /// The id of the datum to update.
  var id: String = String()

  /// The new title of the datum. (Optional)
  var title: String = String()

  /// The new actual data of the datum, such as a password or code, encrypted.
  /// This should decrypt to a string of a json object.
  var data: Kript_Api_ESecret {
    get {return _data ?? Kript_Api_ESecret()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  /// The new initialization vector used to encrypt the data.
  var dataIv: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessToken: Kript_Api_AccessToken? = nil
  fileprivate var _data: Kript_Api_ESecret? = nil
}

struct Kript_Api_UpdateDatumResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The updated datum.
  var datum: Kript_Api_Datum {
    get {return _datum ?? Kript_Api_Datum()}
    set {_datum = newValue}
  }
  /// Returns true if `datum` has been explicitly set.
  var hasDatum: Bool {return self._datum != nil}
  /// Clears the value of `datum`. Subsequent reads from it will return its default value.
  mutating func clearDatum() {self._datum = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _datum: Kript_Api_Datum? = nil
}

struct Kript_Api_CreateDatumRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The access token to identify and authenticate the user.
  var accessToken: Kript_Api_AccessToken {
    get {return _accessToken ?? Kript_Api_AccessToken()}
    set {_accessToken = newValue}
  }
  /// Returns true if `accessToken` has been explicitly set.
  var hasAccessToken: Bool {return self._accessToken != nil}
  /// Clears the value of `accessToken`. Subsequent reads from it will return its default value.
  mutating func clearAccessToken() {self._accessToken = nil}

  /// The title of the datum. (Optional)
  var title: String = String()

  /// The actual data of the datum, such as a password or code, encrypted.
  /// This should decrypt to a string of a json object.
  var data: Kript_Api_ESecret {
    get {return _data ?? Kript_Api_ESecret()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  /// The key used to encrypt the actual data, encrypted using the owner's
  /// public key and decrypted with their private key.
  var dataKey: Kript_Api_EBytes {
    get {return _dataKey ?? Kript_Api_EBytes()}
    set {_dataKey = newValue}
  }
  /// Returns true if `dataKey` has been explicitly set.
  var hasDataKey: Bool {return self._dataKey != nil}
  /// Clears the value of `dataKey`. Subsequent reads from it will return its default value.
  mutating func clearDataKey() {self._dataKey = nil}

  /// The encryption algorithm used to encrypt the actual data.
  var dataEncryptionAlgorithm: Kript_Api_SEncryptionAlgorithm = .unknownSEncryptionAlgorithm

  /// The initialization vector used to encrypt the data.
  var dataIv: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessToken: Kript_Api_AccessToken? = nil
  fileprivate var _data: Kript_Api_ESecret? = nil
  fileprivate var _dataKey: Kript_Api_EBytes? = nil
}

struct Kript_Api_CreateDatumResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The created datum.
  var datum: Kript_Api_Datum {
    get {return _datum ?? Kript_Api_Datum()}
    set {_datum = newValue}
  }
  /// Returns true if `datum` has been explicitly set.
  var hasDatum: Bool {return self._datum != nil}
  /// Clears the value of `datum`. Subsequent reads from it will return its default value.
  mutating func clearDatum() {self._datum = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _datum: Kript_Api_Datum? = nil
}

struct Kript_Api_DeleteDatumRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The access token to identify and authenticate the user.
  var accessToken: Kript_Api_AccessToken {
    get {return _accessToken ?? Kript_Api_AccessToken()}
    set {_accessToken = newValue}
  }
  /// Returns true if `accessToken` has been explicitly set.
  var hasAccessToken: Bool {return self._accessToken != nil}
  /// Clears the value of `accessToken`. Subsequent reads from it will return its default value.
  mutating func clearAccessToken() {self._accessToken = nil}

  /// The id of the datum to delete.
  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessToken: Kript_Api_AccessToken? = nil
}

struct Kript_Api_DeleteDatumResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The deleted datum, as it was before deletion.
  var datum: Kript_Api_Datum {
    get {return _datum ?? Kript_Api_Datum()}
    set {_datum = newValue}
  }
  /// Returns true if `datum` has been explicitly set.
  var hasDatum: Bool {return self._datum != nil}
  /// Clears the value of `datum`. Subsequent reads from it will return its default value.
  mutating func clearDatum() {self._datum = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _datum: Kript_Api_Datum? = nil
}

struct Kript_Api_ShareDatumRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The access token to identify and authenticate the user.
  var accessToken: Kript_Api_AccessToken {
    get {return _accessToken ?? Kript_Api_AccessToken()}
    set {_accessToken = newValue}
  }
  /// Returns true if `accessToken` has been explicitly set.
  var hasAccessToken: Bool {return self._accessToken != nil}
  /// Clears the value of `accessToken`. Subsequent reads from it will return its default value.
  mutating func clearAccessToken() {self._accessToken = nil}

  /// The id of the datum to share.
  var id: String = String()

  /// The id of the user the datum should be shared with.
  var targetID: String = String()

  /// The key used to encrypt the actual data, encrypted using the target user's
  /// public key and decrypted with their private key.
  var dataKey: Kript_Api_EBytes {
    get {return _dataKey ?? Kript_Api_EBytes()}
    set {_dataKey = newValue}
  }
  /// Returns true if `dataKey` has been explicitly set.
  var hasDataKey: Bool {return self._dataKey != nil}
  /// Clears the value of `dataKey`. Subsequent reads from it will return its default value.
  mutating func clearDataKey() {self._dataKey = nil}

  /// The permissions to be granted to this user. These are in addition to any
  /// permissions the user already has.
  var permissions: [Kript_Api_Permission] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessToken: Kript_Api_AccessToken? = nil
  fileprivate var _dataKey: Kript_Api_EBytes? = nil
}

struct Kript_Api_ShareDatumResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The shared datum.
  var datum: Kript_Api_Datum {
    get {return _datum ?? Kript_Api_Datum()}
    set {_datum = newValue}
  }
  /// Returns true if `datum` has been explicitly set.
  var hasDatum: Bool {return self._datum != nil}
  /// Clears the value of `datum`. Subsequent reads from it will return its default value.
  mutating func clearDatum() {self._datum = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _datum: Kript_Api_Datum? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "kript.api"

extension Kript_Api_Permission: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "READ"),
    2: .same(proto: "WRITE"),
    3: .same(proto: "DELETE"),
    4: .same(proto: "SHARE"),
    5: .same(proto: "ADMIN"),
  ]
}

extension Kript_Api_Datum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Datum"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "owner"),
    3: .same(proto: "title"),
    4: .same(proto: "data"),
    5: .standard(proto: "data_encryption_algorithm"),
    6: .standard(proto: "data_iv"),
    7: .same(proto: "accessors"),
    8: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.owner)
      case 3: try decoder.decodeSingularStringField(value: &self.title)
      case 4: try decoder.decodeSingularMessageField(value: &self._data)
      case 5: try decoder.decodeSingularEnumField(value: &self.dataEncryptionAlgorithm)
      case 6: try decoder.decodeSingularBytesField(value: &self.dataIv)
      case 7: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Kript_Api_Datum.Access>.self, value: &self.accessors)
      case 8: try decoder.decodeSingularMessageField(value: &self._metadata)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.dataEncryptionAlgorithm != .unknownSEncryptionAlgorithm {
      try visitor.visitSingularEnumField(value: self.dataEncryptionAlgorithm, fieldNumber: 5)
    }
    if !self.dataIv.isEmpty {
      try visitor.visitSingularBytesField(value: self.dataIv, fieldNumber: 6)
    }
    if !self.accessors.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Kript_Api_Datum.Access>.self, value: self.accessors, fieldNumber: 7)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_Datum, rhs: Kript_Api_Datum) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.title != rhs.title {return false}
    if lhs._data != rhs._data {return false}
    if lhs.dataEncryptionAlgorithm != rhs.dataEncryptionAlgorithm {return false}
    if lhs.dataIv != rhs.dataIv {return false}
    if lhs.accessors != rhs.accessors {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_Datum.Access: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kript_Api_Datum.protoMessageName + ".Access"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "data_key"),
    3: .same(proto: "permissions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.userID)
      case 2: try decoder.decodeSingularMessageField(value: &self._dataKey)
      case 3: try decoder.decodeRepeatedEnumField(value: &self.permissions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if let v = self._dataKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.permissions.isEmpty {
      try visitor.visitPackedEnumField(value: self.permissions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_Datum.Access, rhs: Kript_Api_Datum.Access) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._dataKey != rhs._dataKey {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_Datum.Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kript_Api_Datum.protoMessageName + ".Metadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_id"),
    2: .standard(proto: "created_time"),
    3: .standard(proto: "last_edited"),
    4: .standard(proto: "access_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.ownerID)
      case 2: try decoder.decodeSingularMessageField(value: &self._createdTime)
      case 3: try decoder.decodeSingularMessageField(value: &self._lastEdited)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Kript_Api_Datum.Metadata.AccessMetadata>.self, value: &self.accessMetadata)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 1)
    }
    if let v = self._createdTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._lastEdited {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.accessMetadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Kript_Api_Datum.Metadata.AccessMetadata>.self, value: self.accessMetadata, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_Datum.Metadata, rhs: Kript_Api_Datum.Metadata) -> Bool {
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs._createdTime != rhs._createdTime {return false}
    if lhs._lastEdited != rhs._lastEdited {return false}
    if lhs.accessMetadata != rhs.accessMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_Datum.Metadata.AccessMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kript_Api_Datum.Metadata.protoMessageName + ".AccessMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "grant_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.grantMetadata)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.grantMetadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.grantMetadata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_Datum.Metadata.AccessMetadata, rhs: Kript_Api_Datum.Metadata.AccessMetadata) -> Bool {
    if lhs.grantMetadata != rhs.grantMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_Datum.Metadata.AccessMetadata.PermissionGrantMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kript_Api_Datum.Metadata.AccessMetadata.protoMessageName + ".PermissionGrantMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "granter_id"),
    2: .same(proto: "permission"),
    3: .standard(proto: "is_grant"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.granterID)
      case 2: try decoder.decodeSingularEnumField(value: &self.permission)
      case 3: try decoder.decodeSingularBoolField(value: &self.isGrant)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.granterID.isEmpty {
      try visitor.visitSingularStringField(value: self.granterID, fieldNumber: 1)
    }
    if self.permission != .unknown {
      try visitor.visitSingularEnumField(value: self.permission, fieldNumber: 2)
    }
    if self.isGrant != false {
      try visitor.visitSingularBoolField(value: self.isGrant, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_Datum.Metadata.AccessMetadata.PermissionGrantMetadata, rhs: Kript_Api_Datum.Metadata.AccessMetadata.PermissionGrantMetadata) -> Bool {
    if lhs.granterID != rhs.granterID {return false}
    if lhs.permission != rhs.permission {return false}
    if lhs.isGrant != rhs.isGrant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_GetDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_token"),
    2: .standard(proto: "datum_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._accessToken)
      case 2: try decoder.decodeRepeatedStringField(value: &self.datumIds)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._accessToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.datumIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.datumIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_GetDataRequest, rhs: Kript_Api_GetDataRequest) -> Bool {
    if lhs._accessToken != rhs._accessToken {return false}
    if lhs.datumIds != rhs.datumIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_GetDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "datums"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.datums)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datums.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datums, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_GetDataResponse, rhs: Kript_Api_GetDataResponse) -> Bool {
    if lhs.datums != rhs.datums {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_UpdateDatumRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateDatumRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_token"),
    2: .same(proto: "id"),
    3: .same(proto: "title"),
    4: .same(proto: "data"),
    7: .standard(proto: "data_iv"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._accessToken)
      case 2: try decoder.decodeSingularStringField(value: &self.id)
      case 3: try decoder.decodeSingularStringField(value: &self.title)
      case 4: try decoder.decodeSingularMessageField(value: &self._data)
      case 7: try decoder.decodeSingularBytesField(value: &self.dataIv)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._accessToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.dataIv.isEmpty {
      try visitor.visitSingularBytesField(value: self.dataIv, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_UpdateDatumRequest, rhs: Kript_Api_UpdateDatumRequest) -> Bool {
    if lhs._accessToken != rhs._accessToken {return false}
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs._data != rhs._data {return false}
    if lhs.dataIv != rhs.dataIv {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_UpdateDatumResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateDatumResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "datum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._datum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._datum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_UpdateDatumResponse, rhs: Kript_Api_UpdateDatumResponse) -> Bool {
    if lhs._datum != rhs._datum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_CreateDatumRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateDatumRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_token"),
    3: .same(proto: "title"),
    4: .same(proto: "data"),
    5: .standard(proto: "data_key"),
    6: .standard(proto: "data_encryption_algorithm"),
    7: .standard(proto: "data_iv"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._accessToken)
      case 3: try decoder.decodeSingularStringField(value: &self.title)
      case 4: try decoder.decodeSingularMessageField(value: &self._data)
      case 5: try decoder.decodeSingularMessageField(value: &self._dataKey)
      case 6: try decoder.decodeSingularEnumField(value: &self.dataEncryptionAlgorithm)
      case 7: try decoder.decodeSingularBytesField(value: &self.dataIv)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._accessToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._dataKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.dataEncryptionAlgorithm != .unknownSEncryptionAlgorithm {
      try visitor.visitSingularEnumField(value: self.dataEncryptionAlgorithm, fieldNumber: 6)
    }
    if !self.dataIv.isEmpty {
      try visitor.visitSingularBytesField(value: self.dataIv, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_CreateDatumRequest, rhs: Kript_Api_CreateDatumRequest) -> Bool {
    if lhs._accessToken != rhs._accessToken {return false}
    if lhs.title != rhs.title {return false}
    if lhs._data != rhs._data {return false}
    if lhs._dataKey != rhs._dataKey {return false}
    if lhs.dataEncryptionAlgorithm != rhs.dataEncryptionAlgorithm {return false}
    if lhs.dataIv != rhs.dataIv {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_CreateDatumResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateDatumResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "datum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._datum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._datum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_CreateDatumResponse, rhs: Kript_Api_CreateDatumResponse) -> Bool {
    if lhs._datum != rhs._datum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_DeleteDatumRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteDatumRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_token"),
    2: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._accessToken)
      case 2: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._accessToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_DeleteDatumRequest, rhs: Kript_Api_DeleteDatumRequest) -> Bool {
    if lhs._accessToken != rhs._accessToken {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_DeleteDatumResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteDatumResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "datum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._datum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._datum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_DeleteDatumResponse, rhs: Kript_Api_DeleteDatumResponse) -> Bool {
    if lhs._datum != rhs._datum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_ShareDatumRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShareDatumRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_token"),
    2: .same(proto: "id"),
    3: .standard(proto: "target_id"),
    4: .standard(proto: "data_key"),
    5: .same(proto: "permissions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._accessToken)
      case 2: try decoder.decodeSingularStringField(value: &self.id)
      case 3: try decoder.decodeSingularStringField(value: &self.targetID)
      case 4: try decoder.decodeSingularMessageField(value: &self._dataKey)
      case 5: try decoder.decodeRepeatedEnumField(value: &self.permissions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._accessToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 3)
    }
    if let v = self._dataKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.permissions.isEmpty {
      try visitor.visitPackedEnumField(value: self.permissions, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_ShareDatumRequest, rhs: Kript_Api_ShareDatumRequest) -> Bool {
    if lhs._accessToken != rhs._accessToken {return false}
    if lhs.id != rhs.id {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs._dataKey != rhs._dataKey {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_ShareDatumResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShareDatumResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "datum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._datum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._datum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_ShareDatumResponse, rhs: Kript_Api_ShareDatumResponse) -> Bool {
    if lhs._datum != rhs._datum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
