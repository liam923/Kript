// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: kript/api/universal.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An enumeration of different password hashing algorithms.
enum Kript_Api_HashAlgorithm: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownHashAlgorithm // = 0

  /// Hash the utf-8 encoded password and utf-8 encoded salt using scrypt with N=16384, r=8, p=1, and derived key length = 256 bits
  case scrypt // = 1

  /// Hash the utf-8 encoded password and utf-8 encoded salt using PBKDF2 with SHA512, 20000 iterations, and a derived key length of 256 bits
  case pbkdf2Sha512 // = 2

  /// Hash the utf-8 encoded password and utf-8 encoded salt using Argon2id, with t=75, m=1024, p=1, T=32 (derived key length of 256 bits).
  case argon2 // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownHashAlgorithm
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownHashAlgorithm
    case 1: self = .scrypt
    case 2: self = .pbkdf2Sha512
    case 3: self = .argon2
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownHashAlgorithm: return 0
    case .scrypt: return 1
    case .pbkdf2Sha512: return 2
    case .argon2: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Kript_Api_HashAlgorithm: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Kript_Api_HashAlgorithm] = [
    .unknownHashAlgorithm,
    .scrypt,
    .pbkdf2Sha512,
    .argon2,
  ]
}

#endif  // swift(>=4.2)

/// An enumeration of different symmetric encryption algorithms.
enum Kript_Api_SEncryptionAlgorithm: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownSEncryptionAlgorithm // = 0

  /// Encrypt using AES-256 with a given key and initialization vector, using CBC and PKCS7 padding. If the key is longer than 256 bits or the iv is longer than 128 bits, they are truncated. If they are shorter, they are zero-padded.
  case aes256Cbc // = 1

  /// Encrypt using AES-256 with a given key and initialization vector, using GCM and having a 16-byte authentication tag appended to the cyphertext. If the key is longer than 256 bits or the iv is longer than 128 bits, they are truncated. If they are shorter, they are zero-padded.
  case aes256Gcm // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownSEncryptionAlgorithm
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownSEncryptionAlgorithm
    case 1: self = .aes256Cbc
    case 2: self = .aes256Gcm
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownSEncryptionAlgorithm: return 0
    case .aes256Cbc: return 1
    case .aes256Gcm: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Kript_Api_SEncryptionAlgorithm: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Kript_Api_SEncryptionAlgorithm] = [
    .unknownSEncryptionAlgorithm,
    .aes256Cbc,
    .aes256Gcm,
  ]
}

#endif  // swift(>=4.2)

/// An enumeration of different asymmetric encryption algorithms.
enum Kript_Api_AEncryptionAlgorithm: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownAEncryptionAlgorithm // = 0

  /// Encrypt/Decrypt using RSA with OAEP padding.
  case rsa // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownAEncryptionAlgorithm
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownAEncryptionAlgorithm
    case 1: self = .rsa
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownAEncryptionAlgorithm: return 0
    case .rsa: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Kript_Api_AEncryptionAlgorithm: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Kript_Api_AEncryptionAlgorithm] = [
    .unknownAEncryptionAlgorithm,
    .rsa,
  ]
}

#endif  // swift(>=4.2)

struct Kript_Api_AccessToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var jwt: Kript_Api_JWT {
    get {return _jwt ?? Kript_Api_JWT()}
    set {_jwt = newValue}
  }
  /// Returns true if `jwt` has been explicitly set.
  var hasJwt: Bool {return self._jwt != nil}
  /// Clears the value of `jwt`. Subsequent reads from it will return its default value.
  mutating func clearJwt() {self._jwt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _jwt: Kript_Api_JWT? = nil
}

/// A representation of a JSON Web Token.
struct Kript_Api_JWT {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Base 64 encoded JWT.
  var token: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "kript.api"

extension Kript_Api_HashAlgorithm: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_HASH_ALGORITHM"),
    1: .same(proto: "SCRYPT"),
    2: .same(proto: "PBKDF2_SHA_512"),
    3: .same(proto: "ARGON2"),
  ]
}

extension Kript_Api_SEncryptionAlgorithm: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_S_ENCRYPTION_ALGORITHM"),
    1: .same(proto: "AES_256_CBC"),
    2: .same(proto: "AES_256_GCM"),
  ]
}

extension Kript_Api_AEncryptionAlgorithm: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_A_ENCRYPTION_ALGORITHM"),
    1: .same(proto: "RSA"),
  ]
}

extension Kript_Api_AccessToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccessToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jwt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._jwt)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._jwt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_AccessToken, rhs: Kript_Api_AccessToken) -> Bool {
    if lhs._jwt != rhs._jwt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_JWT: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JWT"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_JWT, rhs: Kript_Api_JWT) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
