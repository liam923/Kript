// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: kript/api/account.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The public information about a user that is visible to anyone.
struct Kript_Api_PublicUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the user.
  var id: String = String()

  /// The username of the user.
  var username: String = String()

  /// The user's public key.
  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  /// The salt used to hash the user's password.
  var passwordSalt: Data = SwiftProtobuf.Internal.emptyData

  /// The hashing algorithm used to hash the user's password.
  var passwordHashAlgorithm: Kript_Api_HashAlgorithm = .unknownHashAlgorithm

  /// The encryption algorithm used to encrypt the user's data keys.
  var dataEncryptionAlgorithm: Kript_Api_AEncryptionAlgorithm = .unknownAEncryptionAlgorithm

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Private information about a user that is only visible to the user.
struct Kript_Api_PrivateUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user's private key, encrypted with the user's password.
  var privateKey: Kript_Api_EBytes {
    get {return _privateKey ?? Kript_Api_EBytes()}
    set {_privateKey = newValue}
  }
  /// Returns true if `privateKey` has been explicitly set.
  var hasPrivateKey: Bool {return self._privateKey != nil}
  /// Clears the value of `privateKey`. Subsequent reads from it will return its default value.
  mutating func clearPrivateKey() {self._privateKey = nil}

  /// The encryption algorithm used to encrypt the private key.
  var privateKeyEncryptionAlgorithm: Kript_Api_SEncryptionAlgorithm = .unknownSEncryptionAlgorithm

  /// The initialization vector used to encrypt the private key.
  var privateKeyIv: Data = SwiftProtobuf.Internal.emptyData

  /// The salt used in generating the key for encrypting/decrypting the private key.
  var privateKeyKeySalt: Data = SwiftProtobuf.Internal.emptyData

  /// The hash algorithm used to generate the key for encrypting/decrypting the private key.
  var privateKeyKeyHashAlgorithm: Kript_Api_HashAlgorithm = .unknownHashAlgorithm

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _privateKey: Kript_Api_EBytes? = nil
}

/// The public and private information about a user.
struct Kript_Api_User {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user's public information.
  var `public`: Kript_Api_PublicUser {
    get {return _public ?? Kript_Api_PublicUser()}
    set {_public = newValue}
  }
  /// Returns true if ``public`` has been explicitly set.
  var hasPublic: Bool {return self._public != nil}
  /// Clears the value of ``public``. Subsequent reads from it will return its default value.
  mutating func clearPublic() {self._public = nil}

  /// The user's private information.
  var `private`: Kript_Api_PrivateUser {
    get {return _private ?? Kript_Api_PrivateUser()}
    set {_private = newValue}
  }
  /// Returns true if ``private`` has been explicitly set.
  var hasPrivate: Bool {return self._private != nil}
  /// Clears the value of ``private``. Subsequent reads from it will return its default value.
  mutating func clearPrivate() {self._private = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _public: Kript_Api_PublicUser? = nil
  fileprivate var _private: Kript_Api_PrivateUser? = nil
}

struct Kript_Api_VerificationToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var jwt: Kript_Api_JWT {
    get {return _jwt ?? Kript_Api_JWT()}
    set {_jwt = newValue}
  }
  /// Returns true if `jwt` has been explicitly set.
  var hasJwt: Bool {return self._jwt != nil}
  /// Clears the value of `jwt`. Subsequent reads from it will return its default value.
  mutating func clearJwt() {self._jwt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _jwt: Kript_Api_JWT? = nil
}

struct Kript_Api_RefreshToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var jwt: Kript_Api_JWT {
    get {return _jwt ?? Kript_Api_JWT()}
    set {_jwt = newValue}
  }
  /// Returns true if `jwt` has been explicitly set.
  var hasJwt: Bool {return self._jwt != nil}
  /// Clears the value of `jwt`. Subsequent reads from it will return its default value.
  mutating func clearJwt() {self._jwt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _jwt: Kript_Api_JWT? = nil
}

struct Kript_Api_SuccessfulLoginMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The refresh token to identify and authenticate the user.
  var refreshToken: Kript_Api_RefreshToken {
    get {return _refreshToken ?? Kript_Api_RefreshToken()}
    set {_refreshToken = newValue}
  }
  /// Returns true if `refreshToken` has been explicitly set.
  var hasRefreshToken: Bool {return self._refreshToken != nil}
  /// Clears the value of `refreshToken`. Subsequent reads from it will return its default value.
  mutating func clearRefreshToken() {self._refreshToken = nil}

  /// The access token to identify and authenticate the user.
  var accessToken: Kript_Api_AccessToken {
    get {return _accessToken ?? Kript_Api_AccessToken()}
    set {_accessToken = newValue}
  }
  /// Returns true if `accessToken` has been explicitly set.
  var hasAccessToken: Bool {return self._accessToken != nil}
  /// Clears the value of `accessToken`. Subsequent reads from it will return its default value.
  mutating func clearAccessToken() {self._accessToken = nil}

  /// The user's information.
  var user: Kript_Api_User {
    get {return _user ?? Kript_Api_User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {self._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _refreshToken: Kript_Api_RefreshToken? = nil
  fileprivate var _accessToken: Kript_Api_AccessToken? = nil
  fileprivate var _user: Kript_Api_User? = nil
}

/// A way to send/receive a two-factor authentication code.
struct Kript_Api_TwoFactor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifier of this two-factor authentication method.
  var id: String = String()

  /// The type of two-factor authentication.
  var type: Kript_Api_TwoFactor.TwoFactorType = .phoneText

  /// Where the two-factor authentication code is sent (phone, email, etc.).
  var destination: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An enumeration of type of two-factor authentication.
  enum TwoFactorType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// A code via text message.
    case phoneText // = 0

    /// A code via phone call.
    case phoneCall // = 1

    /// A code via email.
    case email // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .phoneText
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .phoneText
      case 1: self = .phoneCall
      case 2: self = .email
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .phoneText: return 0
      case .phoneCall: return 1
      case .email: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Kript_Api_TwoFactor.TwoFactorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Kript_Api_TwoFactor.TwoFactorType] = [
    .phoneText,
    .phoneCall,
    .email,
  ]
}

#endif  // swift(>=4.2)

struct Kript_Api_LoginUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An identifier for the user.
  var userIdentifier: Kript_Api_LoginUserRequest.OneOf_UserIdentifier? = nil

  /// The username of the user.
  var username: String {
    get {
      if case .username(let v)? = userIdentifier {return v}
      return String()
    }
    set {userIdentifier = .username(newValue)}
  }

  /// The id of the user.
  var userID: String {
    get {
      if case .userID(let v)? = userIdentifier {return v}
      return String()
    }
    set {userIdentifier = .userID(newValue)}
  }

  /// The hashed password of the user.
  var password: Kript_Api_HString {
    get {return _password ?? Kript_Api_HString()}
    set {_password = newValue}
  }
  /// Returns true if `password` has been explicitly set.
  var hasPassword: Bool {return self._password != nil}
  /// Clears the value of `password`. Subsequent reads from it will return its default value.
  mutating func clearPassword() {self._password = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An identifier for the user.
  enum OneOf_UserIdentifier: Equatable {
    /// The username of the user.
    case username(String)
    /// The id of the user.
    case userID(String)

  #if !swift(>=4.1)
    static func ==(lhs: Kript_Api_LoginUserRequest.OneOf_UserIdentifier, rhs: Kript_Api_LoginUserRequest.OneOf_UserIdentifier) -> Bool {
      switch (lhs, rhs) {
      case (.username(let l), .username(let r)): return l == r
      case (.userID(let l), .userID(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _password: Kript_Api_HString? = nil
}

struct Kript_Api_LoginUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A response, with the type dependent on whether two-factor authentication
  /// is enabled.
  var responseType: Kript_Api_LoginUserResponse.OneOf_ResponseType? = nil

  /// The two-factor authentication information if two-factor authentication
  /// is enabled.
  var twoFactor: Kript_Api_LoginUserResponse.TwoFactorInfo {
    get {
      if case .twoFactor(let v)? = responseType {return v}
      return Kript_Api_LoginUserResponse.TwoFactorInfo()
    }
    set {responseType = .twoFactor(newValue)}
  }

  /// The user's authentication and information if two-factor authentication
  /// is disabled.
  var response: Kript_Api_SuccessfulLoginMessage {
    get {
      if case .response(let v)? = responseType {return v}
      return Kript_Api_SuccessfulLoginMessage()
    }
    set {responseType = .response(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A response, with the type dependent on whether two-factor authentication
  /// is enabled.
  enum OneOf_ResponseType: Equatable {
    /// The two-factor authentication information if two-factor authentication
    /// is enabled.
    case twoFactor(Kript_Api_LoginUserResponse.TwoFactorInfo)
    /// The user's authentication and information if two-factor authentication
    /// is disabled.
    case response(Kript_Api_SuccessfulLoginMessage)

  #if !swift(>=4.1)
    static func ==(lhs: Kript_Api_LoginUserResponse.OneOf_ResponseType, rhs: Kript_Api_LoginUserResponse.OneOf_ResponseType) -> Bool {
      switch (lhs, rhs) {
      case (.twoFactor(let l), .twoFactor(let r)): return l == r
      case (.response(let l), .response(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Represents the relevant information for the two-factor authentication
  /// process to continue.
  struct TwoFactorInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The token used to identify the user through the verification process.
    var verificationToken: Kript_Api_VerificationToken {
      get {return _verificationToken ?? Kript_Api_VerificationToken()}
      set {_verificationToken = newValue}
    }
    /// Returns true if `verificationToken` has been explicitly set.
    var hasVerificationToken: Bool {return self._verificationToken != nil}
    /// Clears the value of `verificationToken`. Subsequent reads from it will return its default value.
    mutating func clearVerificationToken() {self._verificationToken = nil}

    /// The options available for two-factor authentication.
    var options: [Kript_Api_TwoFactor] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _verificationToken: Kript_Api_VerificationToken? = nil
  }

  init() {}
}

struct Kript_Api_SendVerificationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The token used to identify the user through the verification process.
  var verificationToken: Kript_Api_VerificationToken {
    get {return _verificationToken ?? Kript_Api_VerificationToken()}
    set {_verificationToken = newValue}
  }
  /// Returns true if `verificationToken` has been explicitly set.
  var hasVerificationToken: Bool {return self._verificationToken != nil}
  /// Clears the value of `verificationToken`. Subsequent reads from it will return its default value.
  mutating func clearVerificationToken() {self._verificationToken = nil}

  /// The two-factor authentication option used.
  var option: Kript_Api_TwoFactor {
    get {return _option ?? Kript_Api_TwoFactor()}
    set {_option = newValue}
  }
  /// Returns true if `option` has been explicitly set.
  var hasOption: Bool {return self._option != nil}
  /// Clears the value of `option`. Subsequent reads from it will return its default value.
  mutating func clearOption() {self._option = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _verificationToken: Kript_Api_VerificationToken? = nil
  fileprivate var _option: Kript_Api_TwoFactor? = nil
}

struct Kript_Api_SendVerificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether or not sending the verification code was successful.
  var success: Bool = false

  /// The two-factor authentication option used.
  var destination: Kript_Api_TwoFactor {
    get {return _destination ?? Kript_Api_TwoFactor()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  mutating func clearDestination() {self._destination = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _destination: Kript_Api_TwoFactor? = nil
}

struct Kript_Api_VerifyUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The token used to identify the user through the verification process.
  var verificationToken: Kript_Api_VerificationToken {
    get {return _verificationToken ?? Kript_Api_VerificationToken()}
    set {_verificationToken = newValue}
  }
  /// Returns true if `verificationToken` has been explicitly set.
  var hasVerificationToken: Bool {return self._verificationToken != nil}
  /// Clears the value of `verificationToken`. Subsequent reads from it will return its default value.
  mutating func clearVerificationToken() {self._verificationToken = nil}

  /// The two-factor authentication option used.
  var destination: Kript_Api_TwoFactor {
    get {return _destination ?? Kript_Api_TwoFactor()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  mutating func clearDestination() {self._destination = nil}

  /// The two-factor authentication code received on the specified destination.
  var code: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _verificationToken: Kript_Api_VerificationToken? = nil
  fileprivate var _destination: Kript_Api_TwoFactor? = nil
}

struct Kript_Api_VerifyUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user's authentication and information.
  var response: Kript_Api_SuccessfulLoginMessage {
    get {return _response ?? Kript_Api_SuccessfulLoginMessage()}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  mutating func clearResponse() {self._response = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _response: Kript_Api_SuccessfulLoginMessage? = nil
}

struct Kript_Api_UpdatePasswordRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The access token to identify and authenticate the user.
  var accessToken: Kript_Api_AccessToken {
    get {return _accessToken ?? Kript_Api_AccessToken()}
    set {_accessToken = newValue}
  }
  /// Returns true if `accessToken` has been explicitly set.
  var hasAccessToken: Bool {return self._accessToken != nil}
  /// Clears the value of `accessToken`. Subsequent reads from it will return its default value.
  mutating func clearAccessToken() {self._accessToken = nil}

  /// The old hashed password of the user.
  var oldPassword: Kript_Api_HString {
    get {return _oldPassword ?? Kript_Api_HString()}
    set {_oldPassword = newValue}
  }
  /// Returns true if `oldPassword` has been explicitly set.
  var hasOldPassword: Bool {return self._oldPassword != nil}
  /// Clears the value of `oldPassword`. Subsequent reads from it will return its default value.
  mutating func clearOldPassword() {self._oldPassword = nil}

  /// The new hashed password of the user.
  var newPassword: Kript_Api_HString {
    get {return _newPassword ?? Kript_Api_HString()}
    set {_newPassword = newValue}
  }
  /// Returns true if `newPassword` has been explicitly set.
  var hasNewPassword: Bool {return self._newPassword != nil}
  /// Clears the value of `newPassword`. Subsequent reads from it will return its default value.
  mutating func clearNewPassword() {self._newPassword = nil}

  /// The salt used in the new hashed password.
  var newSalt: Data = SwiftProtobuf.Internal.emptyData

  /// The hashing algorithm used to hash the user's new password.
  var newPasswordHashAlgorithm: Kript_Api_HashAlgorithm = .unknownHashAlgorithm

  /// The user's private key, re-encrypted with the user's new password.
  var privateKey: Kript_Api_EBytes {
    get {return _privateKey ?? Kript_Api_EBytes()}
    set {_privateKey = newValue}
  }
  /// Returns true if `privateKey` has been explicitly set.
  var hasPrivateKey: Bool {return self._privateKey != nil}
  /// Clears the value of `privateKey`. Subsequent reads from it will return its default value.
  mutating func clearPrivateKey() {self._privateKey = nil}

  /// The encryption algorithm used to encrypt the user's private key.
  var privateKeyEncryptionAlgorithm: Kript_Api_SEncryptionAlgorithm = .unknownSEncryptionAlgorithm

  /// The initialization vector used to encrypt the private key.
  var privateKeyIv: Data = SwiftProtobuf.Internal.emptyData

  /// The new salt used in generating the key for encrypting/decrypting the private key.
  var privateKeyKeySalt: Data = SwiftProtobuf.Internal.emptyData

  /// The new hash algorithm used to generate the key for encrypting/decrypting the private key.
  var privateKeyKeyHashAlgorithm: Kript_Api_HashAlgorithm = .unknownHashAlgorithm

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessToken: Kript_Api_AccessToken? = nil
  fileprivate var _oldPassword: Kript_Api_HString? = nil
  fileprivate var _newPassword: Kript_Api_HString? = nil
  fileprivate var _privateKey: Kript_Api_EBytes? = nil
}

struct Kript_Api_UpdatePasswordResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user's information.
  var user: Kript_Api_User {
    get {return _user ?? Kript_Api_User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {self._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _user: Kript_Api_User? = nil
}

struct Kript_Api_CreateAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The username of the user.
  var username: String = String()

  /// The hashed password of the user.
  var password: Kript_Api_HString {
    get {return _password ?? Kript_Api_HString()}
    set {_password = newValue}
  }
  /// Returns true if `password` has been explicitly set.
  var hasPassword: Bool {return self._password != nil}
  /// Clears the value of `password`. Subsequent reads from it will return its default value.
  mutating func clearPassword() {self._password = nil}

  /// The salt used in the new hashed password.
  var salt: Data = SwiftProtobuf.Internal.emptyData

  /// The hashing algorithm used to hash the user's password.
  var passwordHashAlgorithm: Kript_Api_HashAlgorithm = .unknownHashAlgorithm

  /// The user's public key.
  var publicKey: Data = SwiftProtobuf.Internal.emptyData

  /// The user's private key, encrypted using the user's password.
  var privateKey: Kript_Api_EBytes {
    get {return _privateKey ?? Kript_Api_EBytes()}
    set {_privateKey = newValue}
  }
  /// Returns true if `privateKey` has been explicitly set.
  var hasPrivateKey: Bool {return self._privateKey != nil}
  /// Clears the value of `privateKey`. Subsequent reads from it will return its default value.
  mutating func clearPrivateKey() {self._privateKey = nil}

  /// The encryption algorithm used to encrypt the user's data.
  var dataEncryptionAlgorithm: Kript_Api_AEncryptionAlgorithm = .unknownAEncryptionAlgorithm

  /// The encryption algorithm used to encrypt the user's private key.
  var privateKeyEncryptionAlgorithm: Kript_Api_SEncryptionAlgorithm = .unknownSEncryptionAlgorithm

  /// The initialization vector used to encrypt the private key.
  var privateKeyIv: Data = SwiftProtobuf.Internal.emptyData

  /// The salt used in generating the key for encrypting/decrypting the private key.
  var privateKeyKeySalt: Data = SwiftProtobuf.Internal.emptyData

  /// The hash algorithm used to generate the key for encrypting/decrypting the private key.
  var privateKeyKeyHashAlgorithm: Kript_Api_HashAlgorithm = .unknownHashAlgorithm

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _password: Kript_Api_HString? = nil
  fileprivate var _privateKey: Kript_Api_EBytes? = nil
}

struct Kript_Api_CreateAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user's authentication and information.
  var response: Kript_Api_SuccessfulLoginMessage {
    get {return _response ?? Kript_Api_SuccessfulLoginMessage()}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  mutating func clearResponse() {self._response = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _response: Kript_Api_SuccessfulLoginMessage? = nil
}

struct Kript_Api_RefreshAuthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The refresh token to identify and authenticate the user.
  var refreshToken: Kript_Api_RefreshToken {
    get {return _refreshToken ?? Kript_Api_RefreshToken()}
    set {_refreshToken = newValue}
  }
  /// Returns true if `refreshToken` has been explicitly set.
  var hasRefreshToken: Bool {return self._refreshToken != nil}
  /// Clears the value of `refreshToken`. Subsequent reads from it will return its default value.
  mutating func clearRefreshToken() {self._refreshToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _refreshToken: Kript_Api_RefreshToken? = nil
}

struct Kript_Api_RefreshAuthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The access token to identify and authenticate the user.
  var accessToken: Kript_Api_AccessToken {
    get {return _accessToken ?? Kript_Api_AccessToken()}
    set {_accessToken = newValue}
  }
  /// Returns true if `accessToken` has been explicitly set.
  var hasAccessToken: Bool {return self._accessToken != nil}
  /// Clears the value of `accessToken`. Subsequent reads from it will return its default value.
  mutating func clearAccessToken() {self._accessToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _accessToken: Kript_Api_AccessToken? = nil
}

struct Kript_Api_GetUserRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The access token to identify and authenticate the user. This is optional.
  var accessToken: Kript_Api_AccessToken {
    get {return _accessToken ?? Kript_Api_AccessToken()}
    set {_accessToken = newValue}
  }
  /// Returns true if `accessToken` has been explicitly set.
  var hasAccessToken: Bool {return self._accessToken != nil}
  /// Clears the value of `accessToken`. Subsequent reads from it will return its default value.
  mutating func clearAccessToken() {self._accessToken = nil}

  /// An identifier of the user to retrieve.
  var userIdentifier: Kript_Api_GetUserRequest.OneOf_UserIdentifier? = nil

  /// The username of the user.
  var username: String {
    get {
      if case .username(let v)? = userIdentifier {return v}
      return String()
    }
    set {userIdentifier = .username(newValue)}
  }

  /// The id of the user.
  var userID: String {
    get {
      if case .userID(let v)? = userIdentifier {return v}
      return String()
    }
    set {userIdentifier = .userID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An identifier of the user to retrieve.
  enum OneOf_UserIdentifier: Equatable {
    /// The username of the user.
    case username(String)
    /// The id of the user.
    case userID(String)

  #if !swift(>=4.1)
    static func ==(lhs: Kript_Api_GetUserRequest.OneOf_UserIdentifier, rhs: Kript_Api_GetUserRequest.OneOf_UserIdentifier) -> Bool {
      switch (lhs, rhs) {
      case (.username(let l), .username(let r)): return l == r
      case (.userID(let l), .userID(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _accessToken: Kript_Api_AccessToken? = nil
}

struct Kript_Api_GetUserResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The information of the specified user.
  var user: Kript_Api_User {
    get {return _user ?? Kript_Api_User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  mutating func clearUser() {self._user = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _user: Kript_Api_User? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "kript.api"

extension Kript_Api_PublicUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublicUser"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "username"),
    3: .standard(proto: "public_key"),
    4: .standard(proto: "password_salt"),
    5: .standard(proto: "password_hash_algorithm"),
    6: .standard(proto: "data_encryption_algorithm"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.username)
      case 3: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 4: try decoder.decodeSingularBytesField(value: &self.passwordSalt)
      case 5: try decoder.decodeSingularEnumField(value: &self.passwordHashAlgorithm)
      case 6: try decoder.decodeSingularEnumField(value: &self.dataEncryptionAlgorithm)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 3)
    }
    if !self.passwordSalt.isEmpty {
      try visitor.visitSingularBytesField(value: self.passwordSalt, fieldNumber: 4)
    }
    if self.passwordHashAlgorithm != .unknownHashAlgorithm {
      try visitor.visitSingularEnumField(value: self.passwordHashAlgorithm, fieldNumber: 5)
    }
    if self.dataEncryptionAlgorithm != .unknownAEncryptionAlgorithm {
      try visitor.visitSingularEnumField(value: self.dataEncryptionAlgorithm, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_PublicUser, rhs: Kript_Api_PublicUser) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.username != rhs.username {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.passwordSalt != rhs.passwordSalt {return false}
    if lhs.passwordHashAlgorithm != rhs.passwordHashAlgorithm {return false}
    if lhs.dataEncryptionAlgorithm != rhs.dataEncryptionAlgorithm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_PrivateUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PrivateUser"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "private_key"),
    2: .standard(proto: "private_key_encryption_algorithm"),
    3: .standard(proto: "private_key_iv"),
    4: .standard(proto: "private_key_key_salt"),
    5: .standard(proto: "private_key_key_hash_algorithm"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._privateKey)
      case 2: try decoder.decodeSingularEnumField(value: &self.privateKeyEncryptionAlgorithm)
      case 3: try decoder.decodeSingularBytesField(value: &self.privateKeyIv)
      case 4: try decoder.decodeSingularBytesField(value: &self.privateKeyKeySalt)
      case 5: try decoder.decodeSingularEnumField(value: &self.privateKeyKeyHashAlgorithm)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._privateKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.privateKeyEncryptionAlgorithm != .unknownSEncryptionAlgorithm {
      try visitor.visitSingularEnumField(value: self.privateKeyEncryptionAlgorithm, fieldNumber: 2)
    }
    if !self.privateKeyIv.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKeyIv, fieldNumber: 3)
    }
    if !self.privateKeyKeySalt.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKeyKeySalt, fieldNumber: 4)
    }
    if self.privateKeyKeyHashAlgorithm != .unknownHashAlgorithm {
      try visitor.visitSingularEnumField(value: self.privateKeyKeyHashAlgorithm, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_PrivateUser, rhs: Kript_Api_PrivateUser) -> Bool {
    if lhs._privateKey != rhs._privateKey {return false}
    if lhs.privateKeyEncryptionAlgorithm != rhs.privateKeyEncryptionAlgorithm {return false}
    if lhs.privateKeyIv != rhs.privateKeyIv {return false}
    if lhs.privateKeyKeySalt != rhs.privateKeyKeySalt {return false}
    if lhs.privateKeyKeyHashAlgorithm != rhs.privateKeyKeyHashAlgorithm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".User"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "public"),
    2: .same(proto: "private"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._public)
      case 2: try decoder.decodeSingularMessageField(value: &self._private)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._public {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._private {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_User, rhs: Kript_Api_User) -> Bool {
    if lhs._public != rhs._public {return false}
    if lhs._private != rhs._private {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_VerificationToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerificationToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jwt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._jwt)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._jwt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_VerificationToken, rhs: Kript_Api_VerificationToken) -> Bool {
    if lhs._jwt != rhs._jwt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_RefreshToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RefreshToken"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jwt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._jwt)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._jwt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_RefreshToken, rhs: Kript_Api_RefreshToken) -> Bool {
    if lhs._jwt != rhs._jwt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_SuccessfulLoginMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SuccessfulLoginMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "refresh_token"),
    2: .standard(proto: "access_token"),
    3: .same(proto: "user"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._refreshToken)
      case 2: try decoder.decodeSingularMessageField(value: &self._accessToken)
      case 3: try decoder.decodeSingularMessageField(value: &self._user)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._refreshToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._accessToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_SuccessfulLoginMessage, rhs: Kript_Api_SuccessfulLoginMessage) -> Bool {
    if lhs._refreshToken != rhs._refreshToken {return false}
    if lhs._accessToken != rhs._accessToken {return false}
    if lhs._user != rhs._user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_TwoFactor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TwoFactor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "destination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      case 3: try decoder.decodeSingularStringField(value: &self.destination)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .phoneText {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_TwoFactor, rhs: Kript_Api_TwoFactor) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_TwoFactor.TwoFactorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PHONE_TEXT"),
    1: .same(proto: "PHONE_CALL"),
    2: .same(proto: "EMAIL"),
  ]
}

extension Kript_Api_LoginUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoginUserRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .standard(proto: "user_id"),
    3: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.userIdentifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.userIdentifier = .username(v)}
      case 2:
        if self.userIdentifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.userIdentifier = .userID(v)}
      case 3: try decoder.decodeSingularMessageField(value: &self._password)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.userIdentifier {
    case .username(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    case .userID(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case nil: break
    }
    if let v = self._password {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_LoginUserRequest, rhs: Kript_Api_LoginUserRequest) -> Bool {
    if lhs.userIdentifier != rhs.userIdentifier {return false}
    if lhs._password != rhs._password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_LoginUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoginUserResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "two_factor"),
    2: .same(proto: "response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Kript_Api_LoginUserResponse.TwoFactorInfo?
        if let current = self.responseType {
          try decoder.handleConflictingOneOf()
          if case .twoFactor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.responseType = .twoFactor(v)}
      case 2:
        var v: Kript_Api_SuccessfulLoginMessage?
        if let current = self.responseType {
          try decoder.handleConflictingOneOf()
          if case .response(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.responseType = .response(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.responseType {
    case .twoFactor(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .response(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_LoginUserResponse, rhs: Kript_Api_LoginUserResponse) -> Bool {
    if lhs.responseType != rhs.responseType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_LoginUserResponse.TwoFactorInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kript_Api_LoginUserResponse.protoMessageName + ".TwoFactorInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "verification_token"),
    2: .same(proto: "options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._verificationToken)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.options)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._verificationToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_LoginUserResponse.TwoFactorInfo, rhs: Kript_Api_LoginUserResponse.TwoFactorInfo) -> Bool {
    if lhs._verificationToken != rhs._verificationToken {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_SendVerificationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendVerificationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "verification_token"),
    2: .same(proto: "option"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._verificationToken)
      case 2: try decoder.decodeSingularMessageField(value: &self._option)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._verificationToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._option {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_SendVerificationRequest, rhs: Kript_Api_SendVerificationRequest) -> Bool {
    if lhs._verificationToken != rhs._verificationToken {return false}
    if lhs._option != rhs._option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_SendVerificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendVerificationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "destination"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.success)
      case 2: try decoder.decodeSingularMessageField(value: &self._destination)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_SendVerificationResponse, rhs: Kript_Api_SendVerificationResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_VerifyUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyUserRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "verification_token"),
    2: .same(proto: "destination"),
    3: .same(proto: "code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._verificationToken)
      case 2: try decoder.decodeSingularMessageField(value: &self._destination)
      case 3: try decoder.decodeSingularStringField(value: &self.code)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._verificationToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_VerifyUserRequest, rhs: Kript_Api_VerifyUserRequest) -> Bool {
    if lhs._verificationToken != rhs._verificationToken {return false}
    if lhs._destination != rhs._destination {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_VerifyUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VerifyUserResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._response)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_VerifyUserResponse, rhs: Kript_Api_VerifyUserResponse) -> Bool {
    if lhs._response != rhs._response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_UpdatePasswordRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdatePasswordRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_token"),
    2: .standard(proto: "old_password"),
    3: .standard(proto: "new_password"),
    4: .standard(proto: "new_salt"),
    5: .standard(proto: "new_password_hash_algorithm"),
    6: .standard(proto: "private_key"),
    7: .standard(proto: "private_key_encryption_algorithm"),
    8: .standard(proto: "private_key_iv"),
    9: .standard(proto: "private_key_key_salt"),
    10: .standard(proto: "private_key_key_hash_algorithm"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._accessToken)
      case 2: try decoder.decodeSingularMessageField(value: &self._oldPassword)
      case 3: try decoder.decodeSingularMessageField(value: &self._newPassword)
      case 4: try decoder.decodeSingularBytesField(value: &self.newSalt)
      case 5: try decoder.decodeSingularEnumField(value: &self.newPasswordHashAlgorithm)
      case 6: try decoder.decodeSingularMessageField(value: &self._privateKey)
      case 7: try decoder.decodeSingularEnumField(value: &self.privateKeyEncryptionAlgorithm)
      case 8: try decoder.decodeSingularBytesField(value: &self.privateKeyIv)
      case 9: try decoder.decodeSingularBytesField(value: &self.privateKeyKeySalt)
      case 10: try decoder.decodeSingularEnumField(value: &self.privateKeyKeyHashAlgorithm)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._accessToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._oldPassword {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._newPassword {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.newSalt.isEmpty {
      try visitor.visitSingularBytesField(value: self.newSalt, fieldNumber: 4)
    }
    if self.newPasswordHashAlgorithm != .unknownHashAlgorithm {
      try visitor.visitSingularEnumField(value: self.newPasswordHashAlgorithm, fieldNumber: 5)
    }
    if let v = self._privateKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.privateKeyEncryptionAlgorithm != .unknownSEncryptionAlgorithm {
      try visitor.visitSingularEnumField(value: self.privateKeyEncryptionAlgorithm, fieldNumber: 7)
    }
    if !self.privateKeyIv.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKeyIv, fieldNumber: 8)
    }
    if !self.privateKeyKeySalt.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKeyKeySalt, fieldNumber: 9)
    }
    if self.privateKeyKeyHashAlgorithm != .unknownHashAlgorithm {
      try visitor.visitSingularEnumField(value: self.privateKeyKeyHashAlgorithm, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_UpdatePasswordRequest, rhs: Kript_Api_UpdatePasswordRequest) -> Bool {
    if lhs._accessToken != rhs._accessToken {return false}
    if lhs._oldPassword != rhs._oldPassword {return false}
    if lhs._newPassword != rhs._newPassword {return false}
    if lhs.newSalt != rhs.newSalt {return false}
    if lhs.newPasswordHashAlgorithm != rhs.newPasswordHashAlgorithm {return false}
    if lhs._privateKey != rhs._privateKey {return false}
    if lhs.privateKeyEncryptionAlgorithm != rhs.privateKeyEncryptionAlgorithm {return false}
    if lhs.privateKeyIv != rhs.privateKeyIv {return false}
    if lhs.privateKeyKeySalt != rhs.privateKeyKeySalt {return false}
    if lhs.privateKeyKeyHashAlgorithm != rhs.privateKeyKeyHashAlgorithm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_UpdatePasswordResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdatePasswordResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._user)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_UpdatePasswordResponse, rhs: Kript_Api_UpdatePasswordResponse) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_CreateAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateAccountRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
    3: .same(proto: "salt"),
    4: .standard(proto: "password_hash_algorithm"),
    5: .standard(proto: "public_key"),
    6: .standard(proto: "private_key"),
    7: .standard(proto: "data_encryption_algorithm"),
    8: .standard(proto: "private_key_encryption_algorithm"),
    9: .standard(proto: "private_key_iv"),
    10: .standard(proto: "private_key_key_salt"),
    11: .standard(proto: "private_key_key_hash_algorithm"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.username)
      case 2: try decoder.decodeSingularMessageField(value: &self._password)
      case 3: try decoder.decodeSingularBytesField(value: &self.salt)
      case 4: try decoder.decodeSingularEnumField(value: &self.passwordHashAlgorithm)
      case 5: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 6: try decoder.decodeSingularMessageField(value: &self._privateKey)
      case 7: try decoder.decodeSingularEnumField(value: &self.dataEncryptionAlgorithm)
      case 8: try decoder.decodeSingularEnumField(value: &self.privateKeyEncryptionAlgorithm)
      case 9: try decoder.decodeSingularBytesField(value: &self.privateKeyIv)
      case 10: try decoder.decodeSingularBytesField(value: &self.privateKeyKeySalt)
      case 11: try decoder.decodeSingularEnumField(value: &self.privateKeyKeyHashAlgorithm)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if let v = self._password {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.salt.isEmpty {
      try visitor.visitSingularBytesField(value: self.salt, fieldNumber: 3)
    }
    if self.passwordHashAlgorithm != .unknownHashAlgorithm {
      try visitor.visitSingularEnumField(value: self.passwordHashAlgorithm, fieldNumber: 4)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 5)
    }
    if let v = self._privateKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.dataEncryptionAlgorithm != .unknownAEncryptionAlgorithm {
      try visitor.visitSingularEnumField(value: self.dataEncryptionAlgorithm, fieldNumber: 7)
    }
    if self.privateKeyEncryptionAlgorithm != .unknownSEncryptionAlgorithm {
      try visitor.visitSingularEnumField(value: self.privateKeyEncryptionAlgorithm, fieldNumber: 8)
    }
    if !self.privateKeyIv.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKeyIv, fieldNumber: 9)
    }
    if !self.privateKeyKeySalt.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKeyKeySalt, fieldNumber: 10)
    }
    if self.privateKeyKeyHashAlgorithm != .unknownHashAlgorithm {
      try visitor.visitSingularEnumField(value: self.privateKeyKeyHashAlgorithm, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_CreateAccountRequest, rhs: Kript_Api_CreateAccountRequest) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs._password != rhs._password {return false}
    if lhs.salt != rhs.salt {return false}
    if lhs.passwordHashAlgorithm != rhs.passwordHashAlgorithm {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs._privateKey != rhs._privateKey {return false}
    if lhs.dataEncryptionAlgorithm != rhs.dataEncryptionAlgorithm {return false}
    if lhs.privateKeyEncryptionAlgorithm != rhs.privateKeyEncryptionAlgorithm {return false}
    if lhs.privateKeyIv != rhs.privateKeyIv {return false}
    if lhs.privateKeyKeySalt != rhs.privateKeyKeySalt {return false}
    if lhs.privateKeyKeyHashAlgorithm != rhs.privateKeyKeyHashAlgorithm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_CreateAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateAccountResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._response)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_CreateAccountResponse, rhs: Kript_Api_CreateAccountResponse) -> Bool {
    if lhs._response != rhs._response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_RefreshAuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RefreshAuthRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "refresh_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._refreshToken)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._refreshToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_RefreshAuthRequest, rhs: Kript_Api_RefreshAuthRequest) -> Bool {
    if lhs._refreshToken != rhs._refreshToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_RefreshAuthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RefreshAuthResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._accessToken)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._accessToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_RefreshAuthResponse, rhs: Kript_Api_RefreshAuthResponse) -> Bool {
    if lhs._accessToken != rhs._accessToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_GetUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUserRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_token"),
    2: .same(proto: "username"),
    3: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._accessToken)
      case 2:
        if self.userIdentifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.userIdentifier = .username(v)}
      case 3:
        if self.userIdentifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.userIdentifier = .userID(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._accessToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    switch self.userIdentifier {
    case .username(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case .userID(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_GetUserRequest, rhs: Kript_Api_GetUserRequest) -> Bool {
    if lhs._accessToken != rhs._accessToken {return false}
    if lhs.userIdentifier != rhs.userIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kript_Api_GetUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUserResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._user)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kript_Api_GetUserResponse, rhs: Kript_Api_GetUserResponse) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
